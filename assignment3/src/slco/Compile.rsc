module slco::Compile

import slco::Parser;
import slco::AST;
import slco::Syntax;
import IO;
import util::Math;
import ParseTree;


/*
Module compiles the SLCO code to executable python code.
*/

void parseCompile(loc l) = compile(parserSLCO(l)); 

void compile(slco::Syntax::Program program) {
	writeFile(program.src[extension="py"].top, program2Python(program));
	return;
}

str program2Python(Program program) {
	println("---------\nGenerating program...");
	str python = "# This file is automatically generated from a slco file\n";
	python += "# Necessary inputs:\n";
	python += "import time\n\n";
	
	//create method for creating the classes
	// Might want to loop over all models, if more models in one file
	python += createModel(program.model);	

	println(python);
	return python;
}

str createModel(Model model) {
	str pythonCode = "";
	println("Create classes");
	pythonCode = "# Defining classes\n";

	for (Class class <- model.classes) {
		pythonCode += createClass(class);
		pythonCode += "\n";
	}
	
	for (Channel channel <- model.channels)
	{
		pythonCode += createChannel(channel);
		pythonCode += "\n";
	}
	pythonCode += "\n";
	

	pythonCode += initializeObjects(model);
	pythonCode += "\n";
	
	return pythonCode;
}

str createClass(Class class) {
	str pythonCode = "# Class\n";
	pythonCode += "class <class.classId>\n";
	int cnt = 0;
	for (SLCOId id <- class.portIds) {
		str count = toString(cnt);
		pythonCode += "\tport<count> = <id>\n";
		cnt += 1;
	}
	pythonCode += "\n";
	
	for (StateMachine sm <- class.stateMachines) {
		pythonCode += "\tdef <sm.stateMachineId>():\n";
		cnt = 0;
		for (Variable var <- sm.variables) {
		// Switch van maken met de types
			pythonCode += "\t\tvar<cnt> = <var.variableId>\n";
			cnt += 1;
		}
		pythonCode += "\n";
	
		for (Variable var <- sm.variables) {
		// Switch van maken met de types
			pythonCode += "\t\tvar<cnt> = <var.variableId>\n";
			cnt += 1;
		}
		
	}
	
	return pythonCode;
}

str createChannel(Channel channel) {
	str pythonCode = "";
	pythonCode += "class <channel.channelId>:\n";
	pythonCode += "\tdef __init__(self):\n";
	pythonCode += "\t\treturn\n\n";
	
	pythonCode += "\t# sync function between ports...\n";
	pythonCode += "\tdef sync(self, <channel.objectIdSource>, <channel.objectIdTarget>):\n";
	pythonCode += "\t\t <channel.objectIdTarget>.states[\"<channel.portIdTarget>\"]= <channel.objectIdSource>.states[\"<channel.portIdSource>\"]";
	return pythonCode;
}

// Initializes the classes
str initializeObjects(Model model) {
	str pythonCode = "";
	// Define the main method
	pythonCode += "# Initialize the classes\n";
	pythonCode += "def makeModel():\n";
	// call all methods from main:
	
	for (Class class <- model.classes) {
		str class_init = "";
		int count = 0;
		str ports = "";
		for (SLCOId portId <- class.portIds) {
			if (count == 0) {
				ports += "\"<portId>\"";
			} else {
				ports += ", \"<portId>\"";
			}
		}
		class_init += "\tports<class.classId> = [<ports>]\n";
		
		count = 0;
		str sms = "";
		str is = "";
		for (StateMachine sm <- class.stateMachines) {
			if (count == 0) {
				sms += "\"<sm.stateMachineId>\"";
				is += "\"<sm.initialState>\"";
			} else {
				sms += ", \"<sm.stateMachineId>\"";
				is += ", \"<sm.initialState>\"";
			}
		}
		class_init += "\tstate_machines<class.classId> = [<sms>]\n";
		class_init += "\tinitial_states<class.classId> = [<is>]\n";
		class_init += "\n";
		pythonCode += class_init;
	}
	
	for (Object obj <- model.objects) {
		pythonCode += "\t<obj.objectId> = <obj.classId>(ports<obj.classId>, state_machines<obj.classId>, initial_states<obj.classId>)\n";
	}
	
	return pythonCode;
}