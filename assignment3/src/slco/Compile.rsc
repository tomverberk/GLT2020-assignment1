module slco::Compile

import slco::Parser;
import slco::AST;
import slco::Syntax;
import IO;
import slco::Load;
import List;

/*
Module compiles the SLCO code to executable python code.
*/
// Entry point
void parseCompile(loc l) = compile(load(l)); 

//Writes the compiled code to a file with extension .py
void compile(Program program) {
	writeFile(|project://assignment3/src/joejoe.py|, program2Python(program));
	println("Done...");
	return;
}

// Necessary inputs and main call to compile to Python code
str program2Python(Program program) {
	println("---------\nGenerating program...");
	str python = "# This file is automatically generated from a slco file\n";
	python += "# Necessary inputs:\n";
	python += "import time\n";
	python += "import queue\n\n\n";
	
	//create method for creating the classes
	// Might want to loop over all models, if more models in one file
	python += createModel(program.model);	
	python += "makeModel()";
	return python;
}

// Create the three blocks of the python code
str createModel(Model model) {
	str pythonCode = "";
	println("Create classes");
	pythonCode = "# Defining classes\n";

	// Create the classes 
	for (Class class <- model.classes) {
		pythonCode += createClass(class);
		pythonCode += "\n";
	}
	
	// Create the channels
	for (Channel channel <- model.channels)
	{
		pythonCode += createChannel(channel);
		pythonCode += "\n";
	}
	pythonCode += "\n";
	
	// initialize the classes and channels
	pythonCode += initializeObjects(model);
	return pythonCode;
}

// Gets the input combination in string format for example it returns "a + b"
// Makes use of recursion 
str getCombination(Comb comb) {
	str com = "";
	switch(comb) {
		case intCon(int iVal): {
			com += "<iVal>";
			return com;
		}
		case IdCon(SLCOId combId): {
			com += "<combId.name>";
			return com;
		}
		case add(Comb left, Comb right): {
			str leftstr = getCombination(left);
			str rightstr = getCombination(right);
			com += "<leftstr> + <rightstr>";
			return com;
		}
		case sub(Comb left, Comb right): {
			str leftstr = getCombination(left);
			str rightstr = getCombination(right);
			com += "<leftstr> - <rightstr>";
			return com;
		}
		case comma(Comb left, Comb right): {
			str leftstr = getCombination(left);
			str rightstr = getCombination(right);
			com += "<leftstr>, <rightstr>";
			return com;
		}
		default: {
	        println("ERROR. Unexpected SendAction <comb> found!");
	        return "/* ERROR! Expression could not be parsed! */";
		}
	}
}

// Returns the input variables, but then in list format, with or without the operator
list[str] getCombList(Comb comb, bool boolean) {
	list[str] com = [];
	switch(comb) {
		case intCon(int iVal): {
			com += "<iVal>";
			return com;
		}
		case IdCon(SLCOId combId): {
			com += "<combId.name>";
			return com;
		}
		case add(Comb left, Comb right): {
			com += getCombList(left, boolean);
			if (boolean) {
				com += "+";
			}
			com += getCombList(right, boolean);
			return com;
		}
		case sub(Comb left, Comb right): {
			com += getCombList(left, boolean);
			if (boolean) {
				com += "-";
			}
			com += getCombList(right, boolean);
			return com;
		}
		case comma(Comb left, Comb right): {
			com += getCombList(left, boolean);
			if (boolean) {
				com += ",";
			}
			com += getCombList(right, boolean);
			return com;
		}
		default: {
	        println("ERROR. Unexpected SendAction <comb> found!");
	        return com + "ERRROR";
		}
	}
}

// Creates the python code for the three different types of transitions
str transitionBody(TransitionBody ts, int count) {
	str return_str = "";
	switch(ts.transitionLine) {
		// Send transtition
		case TransitionLine(SendAction sendAction): {
			if (count == 0) {
				return_str = "\t\t\tif not self.send_input:\n";
				str comb = getCombination(sendAction.combinations);
				return_str += "\t\t\t\tout_var = [<comb>]\n";
				return_str += "\t\t\t\tself.ports[\"<sendAction.portId.name>\"] = out_var\n";
				return_str += "\t\t\t\tprint(\"Sending to port: <sendAction.portId.name>\")\n";
				return_str += "\t\t\t\tself.send_input = True\n";
			} else {
				return_str = "\t\t\tif not self.send_input:\n";
				list[str] comb = getCombList(sendAction.combinations, true);
				int cnt = 0;
				return_str += "\t\t\t\tout_var = [<comb[cnt]>";
				cnt += 1;
				while (cnt < size(comb)) {
					return_str += " <comb[cnt]>";
					cnt += 1;
				}
				return_str += "]\n";
				return_str += "\t\t\t\tself.ports[\"<sendAction.portId.name>\"] = out_var\n";
				return_str += "\t\t\t\tprint(\"Sending to port: <sendAction.portId.name>\")\n";
				return_str += "\t\t\t\tself.send_input = True\n";
			}
			return return_str;
		}
		// Receive transition
		case TransitionLine(ReceiveAction receiveAction): {
			if (count == 0) {
				int cnt = 0;
				list[str] comb = getCombList(receiveAction.combinations, false);
				return_str += "\t\t\tin_var = self.ports[\"<receiveAction.portId.name>\"]\n";
				return_str += "\t\t\tprint(\"Receiving from port: <receiveAction.portId.name>\")\n";
				while (cnt < size(comb)) {
					return_str += "\t\t\t<comb[cnt]> = in_var[<cnt>]\n";
					return_str += "\t\t\tprint(<comb[cnt]>)\n";
					cnt += 1;
				}
				return_str += "\t\t\tself.send_input = False\n";
			} else {
				return_str += "\t\t\tin_var = self.ports[\"<receiveAction.portId.name>\"]\n";
				
				return_str += "\t\t\tif in_var is None:\n";
				return_str += "\t\t\t\tprint(\"No input yet received, still in same state\")\n";
				return_str += "\t\t\t\treturn\n";
				return_str += "\t\t\tprint(\"Receiving from port: <receiveAction.portId.name>\")\n";
				cnt = 0;
				list[str] comb = getCombList(receiveAction.combinations, false);
				while (cnt < size(comb)) {
					return_str += "\t\t\t<comb[cnt]> = in_var[<cnt>]\n";
					return_str += "\t\t\tprint(<comb[cnt]>)\n";
					cnt += 1;
				}
				return_str += "\t\t\tself.ports[\"<receiveAction.portId.name>\"] = None\n";
				return_str += "\t\t\tself.send_input = False\n";
			}
			
			return return_str;
		}
		// Wait transition
		case TransitionLine(WaitAction waitAction): {
			int d = <waitAction.number>[0] / 1000;
			int h = <waitAction.number>[0] / 100 - d * 10;
			return_str += "\t\t\ttime.sleep(<d>.<h>)\n";
			return_str += "\t\t\tprint(\"Waited <d>.<h> seconds\")\n";
			return return_str;
		}
		default: {
		        println("ERROR. Unexpected TransitionBody <ts> found!");
		        return "/* ERROR! Expression could not be parsed! */";
		}
	}

}

// Creates the classes, including ports and state machines.
str createClass(Class class) {
	str pythonCode = "# Class\n";
	pythonCode += "class <class.classId.name>:\n";
	// Initializes dictionaries for the ports and states for the different state machines
	pythonCode += "\tports = {}\n";
	pythonCode += "\tstates = {}\n";
	pythonCode += "\tsend_input = False\n";
	pythonCode += "\n";
	
	// Constructor to create the class
	pythonCode += "\tdef __init__(self, portsInput, initial_states, state_machines):\n";
	pythonCode += "\t\tfor port in portsInput:\n\t\t\tself.ports[port] = None\n\t\tcnt = 0\n\t\twhile cnt \< len(initial_states):\n\t\t\tself.states[state_machines[cnt]] = initial_states[cnt]\n\t\t\tcnt += 1\n\t\t\tself.send_input = False\n\n";
	
	// For each state machine a new function is defined with the variables, states and transitions
	for (StateMachine sm <- class.stateMachines) {
		str input_vars = "";
		pythonCode += "\tdef <sm.stateMachineId.name>(self):\n";
		pythonCode += "\t\tprint(\"Start transition system: <sm.stateMachineId.name>...\")\n";
		cnt = 0;
		for (Transition ts <- sm.transitions) {
			if (cnt == 0) {
				pythonCode += "\t\tif self.states[\'<sm.stateMachineId.name>\'] == \'<ts.stateIdBegin.name>\':\n";
			} else {
				pythonCode += "\t\telif self.states[\'<sm.stateMachineId.name>\'] == \'<ts.stateIdBegin.name>\':\n";
			}
			int count = 0;
			
			for (TransitionBody tb <- ts.transitionBodies) {
				pythonCode += transitionBody(tb, count);
				count += 1;
			}
			pythonCode += "\t\t\tself.states[\"<sm.stateMachineId.name>\"] = \"<ts.stateIdEnd.name>\"\n";
			cnt += 1;
		}
		
		
		pythonCode += "\n";	
	}
	
	return pythonCode;
}

// Creates the classes for the channels. The channels make use of a queue.
str createChannel(Channel channel) {
	str pythonCode = "";
	pythonCode += "class Channel<channel.channelId.name>:\n";
	pythonCode += "\tdef __init__(self):\n";
	pythonCode += "\t\tself.q = queue.Queue(maxsize=0)\n";
	
	pythonCode += "\n";
	pythonCode += "\tdef addQueue(self, <channel.objectIdSource.name>):\n";
	pythonCode += "\t\tself.q.put(<channel.objectIdSource.name>.ports[\"<channel.portIdSource.name>\"])\n";

	pythonCode += "\n";
	pythonCode += "\t# getQueue function between ports...\n";
	pythonCode += "\tdef getQueue(self, <channel.objectIdTarget.name>):\n";
	pythonCode += "\t\t<channel.objectIdTarget.name>.ports[\"<channel.portIdTarget.name>\"] = self.q.get()\n";
	pythonCode += "\n";
	pythonCode += "\t# sync between queues\n";
	pythonCode += "\tdef sync(self, <channel.objectIdSource.name>, <channel.objectIdTarget.name>):\n";
	pythonCode += "\t\tself.addQueue(<channel.objectIdSource.name>)\n";
	pythonCode += "\t\tself.getQueue(<channel.objectIdTarget.name>)\n";
	pythonCode += "\t\tprint(\"Sync between source: <channel.objectIdSource.name> and target: <channel.objectIdTarget.name>...\")";
	pythonCode += "\n";
	pythonCode += "\tdef queueEmpty(self):\n";
	pythonCode += "\t\treturn self.q.empty()\n";
	
	return pythonCode;
}

// Initializes the classes (Channels and classes)
str initializeObjects(Model model) {
	str pythonCode = "";
	// Define the main method
	pythonCode += "# Initialize the classes\n";
	pythonCode += "def makeModel():\n";
	// call all methods from main:
	
	for (Class class <- model.classes) {
		str class_init = "";
		int count = 0;
		str ports = "";
		for (SLCOId portId <- class.portIds) {
			if (count == 0) {
				ports += "\"<portId.name>\"";
			} else {
				ports += ", \"<portId.name>\"";
			}
			count += 1;
		}
		class_init += "\tports<class.classId.name> = [<ports>]\n";
		
		count = 0;
		str sms = "";
		str is = "";
		for (StateMachine sm <- class.stateMachines) {
			if (count == 0) {
				sms += "\"<sm.stateMachineId.name>\"";
				is += "\"<sm.initialState.name>\"";
			} else {
				sms += ", \"<sm.stateMachineId.name>\"";
				is += ", \"<sm.initialState.name>\"";
			}
		}
		class_init += "\tstate_machines<class.classId.name> = [<sms>]\n";
		class_init += "\tinitial_states<class.classId.name> = [<is>]\n";
		class_init += "\n";
		pythonCode += class_init;
	}
	
	for (Object obj <- model.objects) {
		pythonCode += "\t<obj.objectId.name> = <obj.classId.name>(ports<obj.classId.name>, initial_states<obj.classId.name>, state_machines<obj.classId.name>)\n";
	}
	
	for (Channel ch <- model.channels) {
		pythonCode += "\t<ch.channelId.name> = Channel<ch.channelId.name>()\n";
	}
	
	pythonCode += "\t# Below you can add the commands you would like to execute on the channels\n";
	// Code that can be used for the simple calculator example:
	pythonCode += "\n\n";
	pythonCode += "\t# Can be used for the simple calculator example:\n";
	pythonCode += "\tu.Loop()\n";
	pythonCode += "\tc0.sync(u,c)\n";
	pythonCode += "\tc.Main()\n";
	pythonCode += "\tc1.sync(c, u)\n";
	pythonCode += "\tu.Loop()\n";
	pythonCode += "\tu.Loop()\n";
	
	return pythonCode;
}